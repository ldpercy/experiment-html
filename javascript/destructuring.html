<!doctype html>
<html lang="en">
<head>
	<title>Destructuring</title>
	<meta charset="utf-8">
	<link rel="icon" href="../favicon.svg">
	<link rel="stylesheet" href="../[common]/common-style.css">

	<script defer src="../[common]/common-script.js"></script>

</head>
<body>
	<header>
		<h1><a href="">Destructuring</a></h1>
		<nav>
			<a class="colourScheme-selector" href="?colourScheme=light" title="Light colour scheme" data-colourscheme="light">ðŸŸ“</a>
			<a class="colourScheme-selector" href="?colourScheme=dark" title="Dark colour scheme" data-colourscheme="dark">ðŸŸ’</a>
			<a title="To folder" href="./">ðŸ–¿</a>
			<a title="Parent folder" href="../">ðŸ¡…</a>
		</nav>
	</header>


	<main>


	<script>

		class Point {				// how i'd usually write it
			constructor(x,y,z) {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}/* Point */


		class Point1 {
			constructor({x,y,z}) {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}/* Point1 */


		class Point2 {
			constructor({x:x,y:y,z:z}) {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}/* Point2 */


		p = new Point(1,2,3);
		//console.dir(p);

		o2 = { x:4, y:5, z:6 }

		p1 = new Point1({x:2,y:3,z:4})
		//console.dir(p1);
	</script>

	<pre>
		Want to revisit to see if this can be useful for partially specifying arguments for functions and constructors, especially when defaults are available.
	</pre>
	<script>
		function argString(argumentObject) {
			const result = [...argumentObject].map(
				(element) => {
					if (element === null) {
						return 'null';
					}
					else if (element === undefined) {
						return 'undefined';
					}
					else return (typeof element === 'string') ? `'${element}'` : element;
				}
			);
			return result;
		}
	</script>

	<script class="fullwidth">

		console.group('f(a,b,c) - ordinary function, takes anonymous args as an array-like object');

			function f(a='aaa', b='bbb', c='ccc')	{
				console.log(`f(${argString(arguments)}):  ${a},${b},${c}`);
			}

			f();
			f(1234,'ijkl');
			f(1234, null,'hijk');
			f(1234, undefined, 'hijk');		// AHA!! so this is how you do it, have wanted this for ages....

			f(b='1234');	// I think this is just an assignment with a side-effect
			f({b:'1234'});	// passes obj as arg0

		console.groupEnd();



		console.group('f1({a,b,c}) - takes args named a,b,c');

			// f1({a,b,c}) - takes args named a,b,c
			function f1({a,b,c}) {
				console.log(`f1(${argString(arguments)}): ${a},${b},${c}`);
			}

			//f1();					// [chr] Uncaught TypeError: Cannot destructure property 'a' of 'undefined' as it is undefined.
			f1(1234);
			f1(1234,'abcd');		// called like this all of f1's arguments are undefined
			f1({b:'abcd'});

		console.groupEnd();



		console.group('f11({a,b,c}={}) - args named a,b,c  - with a default to prevent destructure failures');
			function f11({a,b,c} = {}) { console.log(`f11(${argString(arguments)}): ${a},${b},${c}`); }

			f11();
		console.groupEnd();



		console.group('f2({x:a,y:b,z:c}) - renames x,y,z to a,b,c');
			function f2({x:a,y:b,z:c})	{
				console.log(`f2(${argString(arguments)}): ${a},${b},${c}`);
			}

			f2('foobar');
			f2({b:'abcd'});
			f2({x:'efgh'});
		console.groupEnd();



		console.group('f3(a,{b,c}) - mixed regular and destructured args');

			function f3(a, {b,c}={}) {			// NB default
				//console.log('asdf');
				console.log(`f3(${argString(arguments)}): ${a},${b},${c}`);
			}

			f3('foobar');
			// [ff] Uncaught TypeError: (destructured parameter) is undefined
			// [chr] Uncaught TypeError: Cannot destructure property 'b' of 'undefined' as it is undefined.

			f3('foo','bar');
			// f3({b:'abcd'});
			// f3({x:'efgh'});

		console.groupEnd();



	</script>





	</main>
</body>
</html>